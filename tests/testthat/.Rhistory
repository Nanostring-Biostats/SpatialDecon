setwd("~/nanostring-cell-mixture-deconvolution")
library("devtools")
library(roxygen2)
setwd("InSituSort")
devtools::document()
devtools::document()
#usethis::use_testthat()
devtools::test() # run unit tests
#usethis::use_testthat()
devtools::test() # run unit tests
#usethis::use_testthat()
devtools::test() # run unit tests
#usethis::use_testthat()
devtools::test() # run unit tests
#usethis::use_testthat()
devtools::test() # run unit tests
#usethis::use_testthat()
devtools::test() # run unit tests
#usethis::use_testthat()
devtools::test() # run unit tests
#usethis::use_testthat()
devtools::test() # run unit tests
expect_error(sum(), NA)
expect_error(stop(), NA)
### test plotting functions
test_that("florets does not error", {
expect_error(florets(x = annot$x, y = annot$y, b = res$beta.granular[!grepl("tumor", rownames(res$beta.granular)), ],
legendwindow = T),
NA)
})
#usethis::use_testthat()
devtools::test() # run unit tests
?reverseDecon
setwd("~/nanostring-cell-mixture-deconvolution")
load("InSituSort/tests/testthat/expectedtestresults.RData")
rm(list = ls())
load("InSituSort/tests/testthat/expectedtestresults.RData")
ls()
load("191 grid decon results.RData")
setwd("~/nanostring-cell-mixture-deconvolution")
load("191 grid decon results.RData")
load("191 grid decon results.RData")
rm(list = ls())
load("191 grid decon results.RData")
inds = (1:15) * 20
temprois = annot$ROI[inds]
inds = which(is.element(annot$ROI, temprois))
sharedgenes = intersect(rownames(safeTME), rownames(snr))
snr = snr[c(sharedgenes, "NegProbe-Kilo"), inds]
raw = raw[c(sharedgenes, "NegProbe-Kilo"), inds]
rownames(raw)[rownames(raw) == "NegProbe-Kilo"] = "NegProbe"
rownames(snr)[rownames(snr) == "NegProbe-Kilo"] = "NegProbe"
annot = annot[inds, c("ROI", "AOI.name", "x", "y", "nuclei")]
# save dataset for examples:
mini_geomx_dataset = list(normalized = snr, raw = raw, annot = annot)
save(mini_geomx_dataset, file = "InSituSort/data/mini_geomx_dataset.RData")
# save test dataset:
snr = snr[sharedgenes, ]
raw = raw[sharedgenes, ]
dim(norm)
rm(list = ls())
load( "InSituSort/tests/testthat/testdata.RData"))
load( "InSituSort/tests/testthat/testdata.RData")
load("InSituSort/tests/testthat/expectedtestresults.RData")
ls()
# reverse decon:
rdres.test = reverseDecon(norm = snr,
beta = res.test$beta,
epsilon = 1)
str(rdres.test)
save(ires.test, res.test, wts.test, mergedX.test, rdres.test, file = "InSituSort/tests/testthat/expectedtestresults.RData")
#usethis::use_testthat()
devtools::test() # run unit tests
setwd("~/nanostring-cell-mixture-deconvolution")
rm(list = ls())
#usethis::use_testthat()
devtools::test() # run unit tests
setwd("InSituSort")
#usethis::use_testthat()
devtools::test() # run unit tests
rdres$cors
setwd("~/nanostring-cell-mixture-deconvolution/InSituSort/tests/testthat")
#### load test data ----------------------
rm(list = ls())
load("testdata.RData")
load("expectedtestresults.RData")
sharedgenes = intersect(rownames(safeTME), rownames(snr))
test_that("deriveWeights is as expected", {
wts = deriveWeights(norm = snr,
raw = raw,
error.model = "dsp")
expect_true(all(abs(wts.test - wts) < 1e-3))
})
# merging tumor profiles:
test_that("mergeTumorIntoX is as expected", {
set.seed(0)
mergedX = mergeTumorIntoX(norm = snr[sharedgenes, ],
bg = replace(snr, TRUE, 1)[sharedgenes, ],
pure.tumor.ids =  annot$AOI.name == "Tumor",
X = safeTME[sharedgenes, ],
K = 5)
expect_true(all(abs(mergedX.test - mergedX) < 1e-3))
})
# insitusort:
set.seed(0)
ires = insitusort(Y = snr[sharedgenes, ],
X = safeTME[sharedgenes, ],
bg = replace(snr[sharedgenes, ], TRUE, 1),
#method = "deconLNR",
resid_thresh = 3, lower_thresh = 0.5)
test_that("insitusort is as expected: beta", {
expect_true(all(abs(ires.test$beta - ires$beta) < 1e-3))
})
test_that("insitusort is as expected: sigma", {
expect_true(all(abs(ires.test$sigmas - ires$sigmas) < 1e-3))
})
test_that("insitusort is as expected: yhat", {
expect_true(all(abs(ires.test$yhat - ires$yhat) < 1e-3))
})
test_that("insitusort is as expected: resids", {
expect_true(all(abs(replace(ires.test$resids, is.na(ires.test$resids), 0) -
replace(ires$resids, is.na(ires$resids), 0)) < 1e-3))
})
test_that("insitusort is as expected: p", {
expect_true(all(abs(ires.test$p - ires$p) < 1e-3))
})
#### test insitusortTILs --------------------------------------------------
res = insitusortTILs(norm = snr,
raw = raw,
bg = replace(snr, TRUE, 1),
is_pure_tumor = annot$AOI.name == "Tumor",
cell_counts = annot$nuclei,
n.tumor.clusters = 5)
### test reverse decon:
rdres = reverseDecon(norm = snr,
beta = res.test$beta,
epsilon = 1)
str(rdres)
str(rdres.test)
expect_true(all(abs(rdres.test$resid.sd - rdres$resid.sd) < 1e-3))
expect_true(all(abs(rdres.test$cors - rdres$cors) < 1e-3))
expect_true(all(abs(rdres.test$cors - rdres$cors) < 1e-3, na.rm = T))
setwd("~/nanostring-cell-mixture-deconvolution")
setwd("InSituSort")
#usethis::use_testthat()
devtools::test() # run unit tests
expect_true(all(abs(rdres.test$resids - rdres$resids) < 1e-3))
str(rdres.test)
### test reverse decon:
rdres = suppressWarnings(reverseDecon(norm = snr,
beta = res.test$beta,
epsilon = 1))
test_that("reverseDecon is as expected: ", {
expect_true(all(abs(rdres.test$resids - rdres$resids) < 1e-3))
expect_true(all(abs(rdres.test$yhat - rdres$yhat) < 1e-3))
expect_true(all(abs(rdres.test$coefs - rdres$coefs) < 1e-3))
expect_true(all(abs(rdres.test$cors - rdres$cors) < 1e-3, na.rm = T))
expect_true(all(abs(rdres.test$resid.sd - rdres$resid.sd) < 1e-3))
})
setwd("~/nanostring-cell-mixture-deconvolution")
##### this script contains the code used to build the package.
rm(list=ls())
setwd("InSituSort")
devtools::document()
#usethis::use_testthat()
devtools::test() # run unit tests
ls
ls()
load("testdata.RData")
setwd("~/nanostring-cell-mixture-deconvolution/InSituSort/tests/testthat")
ls()
load("testdata.RData")
ls()
dim(snr)
rownames(snr)
norm = snr
neg.names = rownames(snr)[c(1, 540)]
neg.names
probepool = c(rep("a", 100), rep("b", (nrow(norm) - 100)))
probepool
neg.names
negnames = neg.names
genes = rownames(norm)
#'
#' Estimates per-datapoint background levels from a GeoMx experiment.
#' In studies with two or more probe pools, different probes will have different
#' background levels. This function provides a convenient way to account for this phenomenon.
#'
#' @param norm Matrix of normalized data, genes in rows and segments in columns.
#'  Must include negprobes, and must have rownames.
#' @param probepool Vector of probe pool names for each gene, aligned to the rows of "norm".
#' @param negnames Names of all negProbes in the dataset. Must be at least one neg.name within each probe pool.
#' @export
derive_GeoMx_background_at_normalized_scale <- function(norm, probepool, negnames) {
# check data input:
if (nrow(norm) != length(probepool)) {
stop("nrow(norm) != length(probepool)")
}
# initialize:
bg = norm * 0
# fill in expected background at scale of normalized data:
for (pool in unique(probepool)) {
# get the pool's negProbes:
tempnegs = intersection(negnames, rownames(norm)[probepool == pool])
if (length(tempnegs) == 0) {
stop(paste0(pool, " probe pool didn't have any negprobes specified"))
}
tempnegfactor = colMeans(norm[tempnegs, , drop = F])
# fill in the corresponding elements of bg:
bg[probepool == pool, ] = sweep(bg[probepool == pool, ], 2, tempnegfactor, "+")
}
return(bg)
}
temp = derive_GeoMx_background_at_normalized_scale(norm = snr, probepool = probepool, negnames = negnames)
# get the pool's negProbes:
tempnegs = intersect(negnames, rownames(norm)[probepool == pool])
#'
#' Estimates per-datapoint background levels from a GeoMx experiment.
#' In studies with two or more probe pools, different probes will have different
#' background levels. This function provides a convenient way to account for this phenomenon.
#'
#' @param norm Matrix of normalized data, genes in rows and segments in columns.
#'  Must include negprobes, and must have rownames.
#' @param probepool Vector of probe pool names for each gene, aligned to the rows of "norm".
#' @param negnames Names of all negProbes in the dataset. Must be at least one neg.name within each probe pool.
#' @export
derive_GeoMx_background_at_normalized_scale <- function(norm, probepool, negnames) {
# check data input:
if (nrow(norm) != length(probepool)) {
stop("nrow(norm) != length(probepool)")
}
# initialize:
bg = norm * 0
# fill in expected background at scale of normalized data:
for (pool in unique(probepool)) {
# get the pool's negProbes:
tempnegs = intersect(negnames, rownames(norm)[probepool == pool])
if (length(tempnegs) == 0) {
stop(paste0(pool, " probe pool didn't have any negprobes specified"))
}
tempnegfactor = colMeans(norm[tempnegs, , drop = F])
# fill in the corresponding elements of bg:
bg[probepool == pool, ] = sweep(bg[probepool == pool, ], 2, tempnegfactor, "+")
}
return(bg)
}
# get the pool's negProbes:
tempnegs = intersect(negnames, rownames(norm)[probepool == pool])
temp = derive_GeoMx_background_at_normalized_scale(norm = snr, probepool = probepool, negnames = negnames)
dim(temp)
temp[c(1:5,105:110), 1:8]
